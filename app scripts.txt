/*function copyDividendData() {
    const sourceSheets = [];
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();

  for (let i = 0; i < 12; i++) {
    const sheet = spreadsheet.getSheets()[i];
    sourceSheets.push(sheet);
  }

  const targetSheet = spreadsheet.getSheetByName("Dividend") || spreadsheet.insertSheet("Dividend");

  const existingData = targetSheet.getDataRange().getValues();

  sourceSheets.forEach(sheet => {
    const sourceData = sheet.getDataRange().getValues();

    for (let i = 1; i < sourceData.length; i++) {
      if (sourceData[i][12] === "Dividend") {
        const rowData = [sourceData[i][10], sourceData[i][11], sourceData[i][14]];
        if (!existingData.some(row => row.join() === rowData.join())) {
          targetSheet.appendRow(rowData);
        }
      }
    }
  });
}*/

function copyDividendData() {
  const sourceSheets = [];
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();

  for (let i = 0; i < 12; i++) {
    const sheet = spreadsheet.getSheets()[i];
    sourceSheets.push(sheet);
  }

  const targetSheet = spreadsheet.getSheetByName("Dividend") || spreadsheet.insertSheet("Dividend");

  // Determine the last row with data in columns A, B, or C.
  let lastRowABC = 2; // Start from row 2 (since we append from row 3)

  const columnAValues = targetSheet.getRange("A:A").getValues().flat().filter(String);
  const columnBValues = targetSheet.getRange("B:B").getValues().flat().filter(String);
  const columnCValues = targetSheet.getRange("C:C").getValues().flat().filter(String);

  const maxRowCount = Math.max(columnAValues.length, columnBValues.length, columnCValues.length);

  lastRowABC = Math.max(2, maxRowCount);

  // Get existing data from row 3 onwards, limited to the first 3 columns.
  const existingData = (lastRowABC > 2) ? targetSheet.getRange(3, 1, lastRowABC - 2, 3).getValues() : [];

  // Determine the starting row for appending.
  let appendRow = lastRowABC + 1;

  sourceSheets.forEach(sheet => {
    const sourceData = sheet.getDataRange().getValues();

    for (let i = 1; i < sourceData.length; i++) {
      if (sourceData[i][12] === "Dividend") {
        const rowData = [sourceData[i][10], sourceData[i][11], sourceData[i][14]];

        let exists = false;
        if (existingData.length > 0) {
          exists = existingData.some(row => row.join() === rowData.join());
        }

        if (!exists) {
          // Append the row to columns A, B, C, starting from appendRow.
          targetSheet.getRange(appendRow, 1, 1, 3).setValues([rowData]);
          appendRow++; // Increment appendRow for the next row.
        }
      }
    }
  });
}


function onEdit(e) {
  var range = e.range;
  var sheet = e.source.getActiveSheet();



     // Check if the edited cell is in column D or F
  if ((sheet.getName() === "Stock Journal" && range.getColumn() == 4) || 
     (sheet.getName() === "Stock Journal" && range.getColumn() == 6)) {
    var row = range.getRow();
    var columnDValue = sheet.getRange(row, 4).getValue();
    var columnFValue = sheet.getRange(row, 6).getValue();
  
    // Check if column D is "Sell" and column F is positive
    if (columnDValue === "Sell" && columnFValue > 0) {
     // sheet.getRange(row, 6).setValue(-columnFValue);
    }
    else if  (columnDValue === "Withdrawal" && columnFValue > 0) {
      sheet.getRange(row, 6).setValue(-1);
      sheet.getRange(row, 2).setValue("Cash");
    }
    else if  ((columnDValue === "Deposit" && columnFValue <= 0)||
             (columnDValue === "Deposit" && columnFValue >= 0)){
      sheet.getRange(row, 6).setValue(1);
      sheet.getRange(row, 2).setValue("Cash");
    }
     else if  (columnDValue === "Bonus") {
        sheet.getRange(row, 5).setValue(0);
    }
    /*  else if  (columnDValue === "Buy"){
      sheet.getRange(row, 6).setValue(null);
      sheet.getRange(row, 5).setValue(null);
     }*/
  }

       // Check if the edited cell is in column M or O
  if ((sheet.getName() === "Stock Journal" && range.getColumn() == 13) || 
      (sheet.getName() === "Stock Journal" && range.getColumn() == 15)) {
    var row = range.getRow();
    var columnMValue = sheet.getRange(row, 13).getValue();
    var columnOValue = sheet.getRange(row, 15).getValue();

    // Check if column M is "Sell" and column O is positive
    if (columnMValue === "Sell" || columnMValue === "Stock Tfr - Out" && columnOValue > 0) {
      //sheet.getRange(row, 15).setValue(-columnOValue);
    }
    else if  (columnMValue === "Withdrawal" && columnOValue > 0) {
      sheet.getRange(row, 15).setValue(-1);
      sheet.getRange(row, 11).setValue("Cash");
    }
    else if  ((columnMValue === "Deposit" && columnOValue <= 0)||
            (columnMValue === "Deposit" && columnOValue >= 0)){
      sheet.getRange(row, 15).setValue(1);
      sheet.getRange(row, 11).setValue("Cash");
    }
     else if  (columnMValue === "Bonus") {
        sheet.getRange(row, 14).setValue(0);
    }
     /* else if  (columnMValue === "Buy"){
      sheet.getRange(row, 15).setValue(null);
      sheet.getRange(row, 14).setValue(null);
      }*/
  }


 if (sheet.getName() === "Stock Journal") {
  // --- Logic from the "Automated Formula Deletion" script starts here ---

  // --- CONFIGURATION for Formula Deletion ---
  const TARGET_SHEET_NAME = "Stock Journal";
  const KEYWORDS_TO_SEARCH = ["Split", "Demerger", "Bonus"];
  const KEYWORD_COLUMN_NUMBERS = [4, 13, 22];
  const FORMULA_COLUMN_OFFSET = 3;
  // --- END CONFIGURATION for Formula Deletion ---

  // Exit if the edited sheet is not the target sheet for formula deletion.
  if (sheet.getName() !== TARGET_SHEET_NAME) {
    return; // This return will exit the entire onEdit function if not on "Stock Journal"
  }

  // Get the row and column of the cell that was just edited.
  const range = e.range; // e.range is already available from the onEdit parameter
  const editedRow = range.getRow();
  const editedCol = range.getColumn();

  // Check if the edited column is one of the designated keyword columns.
  if (KEYWORD_COLUMN_NUMBERS.includes(editedCol)) {
    const cellValueInKeywordCol = sheet.getRange(editedRow, editedCol).getDisplayValue();

    let keywordFound = false;
    if (typeof cellValueInKeywordCol === 'string') {
      const lowerCaseCellValue = cellValueInKeywordCol.toLowerCase();
      for (const keyword of KEYWORDS_TO_SEARCH) {
        if (lowerCaseCellValue.includes(keyword.toLowerCase())) {
          keywordFound = true;
          break;
        }
      }
    }

    if (keywordFound) {
      const formulaTargetCol = editedCol + FORMULA_COLUMN_OFFSET;
      const formulaTargetCell = sheet.getRange(editedRow, formulaTargetCol);

      if (formulaTargetCell.getFormula()) {
        formulaTargetCell.copyTo(formulaTargetCell, SpreadsheetApp.CopyPasteType.PASTE_VALUES, false);
      }
    }
  }
  // --- Logic from the "Automated Formula Deletion" script ends here ---
}
}


/* Back up
function onEdit(e) {
  var range = e.range;
  var sheet = e.source.getActiveSheet();


     // Check if the edited cell is in column D or F
  if (sheet.getName() === "Stock Journal" && range.getColumn() == 4 || range.getColumn() == 6) {
    var row = range.getRow();
    var columnDValue = sheet.getRange(row, 4).getValue();
    var columnFValue = sheet.getRange(row, 6).getValue();
    var columnHValue = sheet.getRange(row, 8).getValue();

    // Check if column D is "Sell" and column F is positive
    if (columnDValue === "Sell" && columnFValue > 0) {
      sheet.getRange(row, 6).setValue(-columnFValue);
    }
    else if  (columnDValue === "Withdrawal" && columnFValue > 0) {
      sheet.getRange(row, 6).setValue(-1);
      sheet.getRange(row, 2).setValue("Cash");
    }
    else if  (columnDValue === "Deposit" && columnFValue <= 0||columnFValue >= 0){
      sheet.getRange(row, 6).setValue(1);
      sheet.getRange(row, 2).setValue("Cash");
    }
  }

}*/

function generateTrade(stockQuant, stockPrice, action) {
  /**
   * Creates a trade object with the specified quantity, price, and action.
   *
   * @param {number} stockQuant - The quantity of the stock.
   * @param {number} stockPrice - The price of the stock.
   * @param {string} action - The action to be performed (e.g., "Buy", "Sell", "SPLIT").
   * @returns {Object} - An object representing the trade, with properties for `shares`, `price`, and `action`.
   */
  return {
    shares: stockQuant,
    price: stockPrice,
    action: action
  };
}

function generateFifo(security, actions, quantity, price) {
  /**
   * Generates a portfolio using the FIFO (First-In-First-Out) method based on the provided security, actions, quantity, and price data.
   *
   * @param {Array} security - An array of security tickers.
   * @param {Array} actions - An array of actions to be performed (e.g., "Buy", "Sell", "SPLIT").
   * @param {Array} quantity - An array of quantities corresponding to each action.
   * @param {Array} price - An array of prices corresponding to each action.
   * @returns {Map} - A Map containing the portfolio, where keys are security tickers and values are arrays of trade objects.
   */
  let portfolio = new Map();
  for (var i = 0; i < security?.length; i++) {

    let ticker = security[i].toString();
    let action = actions[i].toString();
    let stockQuant = Number(quantity[i]);
    let stockPrice = Number(price[i]);
    let trade = generateTrade(stockQuant, stockPrice, action);

    if (action == "Buy"  || action == "Stock Tfr - In"|| action == "Resulting") {
      let activeTrades = portfolio.get(ticker);
      if (activeTrades == null) {
        portfolio.set(ticker, [trade]);
      } else {
        activeTrades.push(trade);
      }
    }

    if (action.toUpperCase() == "SPLIT") {
      let activeTrades = portfolio.get(ticker);
      let ratio = quantity[i].toString().split(":");
      activeTrades = activeTrades.map((trade) => {
        trade.shares = trade.shares * ratio[0];
        trade.price = trade.price / ratio[0];
        trade.shares = trade.shares * ratio[1];
        trade.price = trade.price / ratio[1];
        return trade;
      });
    }

        if (action.toUpperCase() == "DEMERGER") {
      let activeTrades = portfolio.get(ticker);
      let ratio = quantity[i].toString().split(":");
      activeTrades = activeTrades.map((trade) => {
      trade.price = trade.price*ratio[0];
        return trade;
      });
    }

      if (action == "Bonus") {
      let activeTrades = portfolio.get(ticker);
      let ratioParts = quantity[i].toString().split(":");
      let ratio = parseInt(ratioParts[1]) / parseInt(ratioParts[0]);
      activeTrades = activeTrades.map((trade) => {
       trade.shares = trade.shares + (trade.shares*ratio);
       trade.price = trade.price / (1+ ratio);
       return trade;
      });
    }

if (action == "Sell" || action == "Stock Tfr - Out") {
   let activeTrades = portfolio.get(ticker);
   let precision = 5;
   if (activeTrades != null) {
      let sharesToSell = Number(Number(trade.shares).toFixed(precision));
      while (sharesToSell > 0) {
         sharesToSell = Number(Number(sharesToSell).toFixed(precision));
         if (activeTrades.length > 0) {
            let itemToSell = activeTrades[0];
            itemToSell.shares = Number(Number(itemToSell.shares).toFixed(precision));
            if (itemToSell.shares == sharesToSell) {
               sharesToSell = 0;
               activeTrades.splice(0, 1);

            } else if (itemToSell.shares < sharesToSell) {
               sharesToSell -= itemToSell.shares;
               activeTrades.splice(0, 1);

            } else {
               itemToSell.shares -= sharesToSell;
               sharesToSell = 0;

            }
         }
      }

      if (activeTrades.length == 0) {
         portfolio.delete(ticker);
      }
   }
}

    /*if ((action == "Sell")) {
      let activeTrades = portfolio.get(ticker);
     // let precision = 5;
      if (activeTrades != null) {
       // let sharesToSell = Number(Number(trade.shares).toFixed(precision));
        let sharesToSell = Number(trade.shares);
     //   for (let j = 0; j < activeTrades.length && sharesToSell > 0; j++) {
        for (let j = 0; j < activeTrades && sharesToSell > 0; j++) {
          let itemToSell = activeTrades[j];
          //itemToSell.shares = Number(Number(itemToSell.shares).toFixed(precision));
          itemToSell.shares = Number(itemToSell.shares);
          if (itemToSell.shares === sharesToSell) {
            sharesToSell = 0;
            activeTrades.splice(j, 1);
          } else if (itemToSell.shares < sharesToSell) {
            sharesToSell -= itemToSell.shares;
            activeTrades.splice(j, 1);
          } else {
            itemToSell.shares -= sharesToSell;
            sharesToSell = 0;
          }
        }

        if (activeTrades.length === 0) {
          portfolio.delete(ticker);
        }
      }
    }
 */
 
  }
  return portfolio;
}

function myPositions(security, actions, quantity, price) {
  /**
   * Calculates the current positions in a portfolio based on the provided security, actions, quantity, and price data.
   *
   * @param {Array} security - An array of security tickers.
   * @param {Array} actions - An array of actions to be performed (e.g., "Buy", "Sell", "SPLIT").
   * @param {Array} quantity - An array of quantities corresponding to each action.
   * @param {Array} price - An array of prices corresponding to each action.
   * @returns {Array} - An array of arrays, where each inner array represents a position with the ticker, shares, and average price.
   */
  let portfolio = generateFifo(security, actions, quantity, price);

  let returnArry = [];
  portfolio.forEach((value, key) => {
    let shares = 0;
    let totalCost = 0;
    let avgPrice = 0;
    value.map(trade => {
      shares += trade.shares;
      totalCost += trade.shares * trade.price;
    });

    avgPrice = totalCost / shares;
    returnArry.push([key, shares, avgPrice]);
  });

    // Sort the returnArry by ticker name (key) in ascending order
  returnArry.sort((a, b) => a[0].localeCompare(b[0]));
  
  return returnArry;
}

function fetchAndAppendData(searchCriteria) {
  Logger.log("Starting fetchAndAppendData with searchCriteria: " + searchCriteria);

  // Get the active spreadsheet and sheet
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var activeSheet = spreadsheet.getActiveSheet();

  // Iterate through all sheets
  var allSheets = spreadsheet.getSheets();
  for (var i = 0; i < allSheets.length; i++) {
    var sheet = allSheets[i];

    Logger.log("Processing sheet: " + sheet.getName());

    // Find the search criteria in the sheet
    var searchRange = sheet.createTextFinder(searchCriteria).findNext();

    if (searchRange) {
      Logger.log("Found search criteria in sheet: " + sheet.getName());

      // Get the column and row indices of the search cell
      var column = searchRange.getColumn();
      var row = searchRange.getRow();

      // Get the ranges of the cells to the left and right
      var leftCellRange = sheet.getRange(row, column - 1);
      var rightCellRange = sheet.getRange(row, column + 1);

      // Get the values of the left and right cells
      var leftCellValue = leftCellRange.getValue();
      var rightCellValue = rightCellRange.getValue();

      Logger.log("Extracted values: " + leftCellValue + ", " + rightCellValue);

      // Append the data to the active sheet
      activeSheet.appendRow([sheet.getName(), leftCellValue, rightCellValue]);
      Logger.log("Appended row to active sheet.");
    } else {
      Logger.log("Search criteria not found in sheet: " + sheet.getName());
    }
  }

  Logger.log("fetchAndAppendData completed successfully.");
}

function fetchExpenses(searchCriteria) {
  Logger.log("Starting fetchExpenses with searchCriteria: " + searchCriteria);
  fetchAndAppendData(searchCriteria);
  Logger.log("fetchExpenses completed successfully.");
  return "Data appended successfully";
}


function sumExpensesByCategory(category) {
  // Get all sheets in the spreadsheet
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheets = ss.getSheets();

  // Initialize an empty array to store the results
  var results = [];

  // Iterate through each sheet
  for (var i = 0; i < sheets.length; i++) {
    var sheet = sheets[i];

    // Get the data range of the sheet
    var dataRange = sheet.getDataRange();

    // Get the values of the data range
    var values = dataRange.getValues();

    // Find the column index of the "Category" column
    var categoryColumnIndex = -1;
    var headerRow = values[0];
    for (var j = 0; j < headerRow.length; j++) {
      if (headerRow[j] === "Category") {
        categoryColumnIndex = j;
        break;
      }
    }

    // If the "Category" column is found, proceed
    if (categoryColumnIndex !== -1) {
      // Find the column index of the "DR" column
      var drColumnIndex = -1;
      for (var j = 0; j < headerRow.length; j++) {
        if (headerRow[j] === "DR") {
          drColumnIndex = j;
          break;
        }
      }

      // If the "DR" column is found, proceed
      if (drColumnIndex !== -1) {
        // Iterate through each row
        for (var j = 1; j < values.length; j++) { // Start from row 1 to skip header
          var row = values[j];
          if (row[categoryColumnIndex] === category) {
            // Extract month from the date (assuming date is in column 0)
            var date = row[0]; // Assuming date is in the first column
            var month = Utilities.formatDate(date, Session.getScriptTimeZone(), "MM"); 

            // Find or create an entry for the month in the results array
            var monthIndex = -1;
            for (var k = 0; k < results.length; k++) {
              if (results[k][0] === month) {
                monthIndex = k;
                break;
              }
            }
            if (monthIndex === -1) {
              monthIndex = results.push([month, 0]) - 1;
            }

            // Add the "DR" value to the total for the month
            results[monthIndex][1] += parseFloat(row[drColumnIndex]);
          }
        }
      }
    }
  }

  return results;
}


/**
 * @OnlyCurrentDoc
 *
 * This script fetches a search key (either from the calling cell or as a parameter),
 * searches for it in the first 12 sheets of the Google Sheet,
 * and if found, collects data from adjacent cells (2 left, 1 right) for all occurrences.
 * All collected data is then pasted below and to the right of the calling cell,
 * with each new match appearing on a new row.
 *
 * @param {string} [key] - The search key to look for. This parameter is expected
 * when called from the custom menu.
 */
function FETCH_AND_PASTE(key) {
  // Get the active spreadsheet and the sheet where the function was called.
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const activeSheet = spreadsheet.getActiveSheet();
  const activeCell = activeSheet.getActiveCell(); // This will be the cell that was active when the menu item was clicked.

  // Determine the search key:
  // For menu-driven execution, the key will always be passed as a parameter.
  const searchKey = String(key);

  // Log the search key for debugging purposes.
  console.log(`Search key: "${searchKey}" from cell ${activeCell.getA1Notation()}`);

  // If the search key is empty, do nothing.
  if (!searchKey) {
    console.log("Search key is empty. Exiting.");
    return;
  }

  // Get all sheets in the spreadsheet.
  const sheets = spreadsheet.getSheets();

  // Limit the search to the first 12 sheets.
  const sheetsToSearch = sheets.slice(0, Math.min(sheets.length, 12));

  // Array to store all found [valueLeft, valueRight] pairs.
  const foundResults = [];

  // Iterate through each sheet to search for the key.
  for (const sheet of sheetsToSearch) {
    // Skip the active sheet to prevent self-referencing issues.
    if (sheet.getName() === activeSheet.getName()) {
      console.log(`Skipping active sheet: ${sheet.getName()}`);
      continue;
    }

    console.log(`Searching in sheet: ${sheet.getName()}`);

    // Get the entire data range of the current sheet.
    // This is more efficient than getting individual cells repeatedly.
    const range = sheet.getDataRange();
    const values = range.getValues(); // Get all values in the range as a 2D array.

    // Iterate through rows and columns to find the search key.
    for (let r = 0; r < values.length; r++) {
      for (let c = 0; c < values[r].length; c++) {
        // Check if the current cell's value matches the search key.
        // Convert to string for consistent comparison, handling numbers, booleans, etc.
        // Use String(value).toLowerCase() for case-insensitive comparison.
        if (String(values[r][c]).toLowerCase() === searchKey.toLowerCase()) {
          console.log(`Found "${searchKey}" in sheet "${sheet.getName()}" at row ${r + 1}, column ${c + 1}`);

          let valueLeft = "";
          let valueRight = "";

          // Get the value from 2 cells left of the found cell.
          // Ensure the column index is not negative.
          if (c - 2 >= 0) {
            valueLeft = values[r][c - 2];
          } else {
            console.log(`Cannot get value 2 cells left: Column index ${c - 2} is out of bounds.`);
          }

          // Get the value from 1 cell right of the found cell.
          // Ensure the column index is within the row's bounds.
          if (c + 1 < values[r].length) {
            valueRight = values[r][c + 1];
          } else {
            console.log(`Cannot get value 1 cell right: Column index ${c + 1} is out of bounds.`);
          }

          // Add the found pair to the results array.
          foundResults.push([valueLeft, valueRight]);
        }
      }
    }
  }

  // Determine the starting row and column for pasting the data.
  const startRow = activeCell.getRow() + 1;
  const startCol = activeCell.getColumn();

  // Clear previous content in the target area to avoid stale data.
  // We'll clear a reasonable range, assuming previous results might have been there.
  // This clears from the row below the active cell, across two columns, down to a few rows.
  // You might adjust the number of rows to clear based on expected max results.
  activeSheet.getRange(startRow, startCol, 1000, 2).clearContent(); // Clear up to 100 rows below

  if (foundResults.length > 0) {
    // Get the target range for pasting all results.
    // The range starts at (startRow, startCol) and has dimensions (number of results, 2 columns).
    const targetRange = activeSheet.getRange(startRow, startCol, foundResults.length, 2);

    // Paste all collected values into the target range.
    targetRange.setValues(foundResults);
    console.log(`Pasted ${foundResults.length} result(s) starting at ${targetRange.getA1Notation()}`);
  } else {
    // If no results were found, log a message.
    console.log(`Search key "${searchKey}" not found in the first 12 sheets. Target cells cleared.`);
  }
}

/**
 * Adds a custom menu to the spreadsheet when it's opened.
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('Custom Actions')
      .addItem('Fetch and Paste Data', 'runFetchAndPaste')
      .addToUi();
}

/**
 * A wrapper function to call FETCH_AND_PASTE from the menu.
 * It prompts the user for the search key and then executes the main logic.
 */
function runFetchAndPaste() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt(
      'Fetch & Paste',
      'Enter the name to fetch expenses:',
      ui.ButtonSet.OK_CANCEL);

  // Process the user's response.
  if (response.getSelectedButton() == ui.Button.OK) {
    const searchKey = response.getResponseText();
    FETCH_AND_PASTE(searchKey); // Call your main function with the provided key
  } else {
    ui.alert('Operation Cancelled', 'The fetch and paste operation was cancelled.', ui.ButtonSet.OK);
  }
}



function FDData() {
  const sourceSheets = [];
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();

  for (let i = 0; i < 12; i++) {
    const sheet = spreadsheet.getSheets()[i];
    if (sheet) { // Ensure the sheet exists
      sourceSheets.push(sheet);
    } else {
      console.warn(`Sheet at index ${i} not found. Skipping.`);
    }
  }

  const targetSheet = spreadsheet.getSheetByName("FD") || spreadsheet.insertSheet("FD");

  // Determine the last row with data in columns A, B, or C.
  let lastRowABC = 2; // Start from row 2 (since we append from row 3)

  const columnAValues = targetSheet.getRange("A:A").getValues().flat().filter(String);
  const columnBValues = targetSheet.getRange("B:B").getValues().flat().filter(String);
  const columnCValues = targetSheet.getRange("C:C").getValues().flat().filter(String);

  const maxRowCount = Math.max(columnAValues.length, columnBValues.length, columnCValues.length);

  lastRowABC = Math.max(2, maxRowCount);

  // Get existing data from row 3 onwards, limited to the first 3 columns.
  const existingData = (lastRowABC > 2) ? targetSheet.getRange(3, 1, lastRowABC - 2, 3).getValues() : [];

  // Determine the starting row for appending.
  let appendRow = lastRowABC + 1;

  sourceSheets.forEach(sheet => {
    const sourceData = sheet.getDataRange().getValues();
    const maxCols = sourceData.length > 0 ? sourceData[0].length : 0; // Get the maximum number of columns in the source data

    for (let i = 1; i < sourceData.length; i++) {
      // Iterate through columns: 2, 7, 12, 17... (0-indexed: 2, 7, 12, 17...)
      for (let colOffset = 0; ; colOffset += 5) {
        const checkColIndex = 2 + colOffset; // 3rd column (index 2), then 8th (index 7), etc.

        // Ensure we don't go out of bounds for checking the keyword column itself.
        if (checkColIndex >= maxCols) {
          break; // No more columns to check in this row
        }

        // We need 2 columns to the left (checkColIndex - 2)
        // We might need 2 columns to the right (checkColIndex + 2 for "Investment Refund")
        if (checkColIndex - 2 < 0 || checkColIndex + 2 >= maxCols) {
            // Cannot extract all required data (out of bounds), skip this checkColIndex
            continue;
        }

        const keywordValue = sourceData[i][checkColIndex];
        let extractedCol3; // This variable will hold the third piece of data for rowData

        // Check for "LR-FD" or "Investment Refund"
        if (keywordValue === "LR-FD" || keywordValue === "Investment Refund") {

          if (keywordValue === "Investment Refund") {
            // For "Investment Refund", take value from 2 columns to the right and make it negative
            extractedCol3 = sourceData[i][checkColIndex + 2];
            const numericValue = parseFloat(extractedCol3);
            if (!isNaN(numericValue)) {
              extractedCol3 = -Math.abs(numericValue); // Ensure it's negative
            } else {
              // Log a warning if the value isn't a number
              console.warn(`Value at column ${checkColIndex + 3} (2 columns right of "Investment Refund") in sheet "${sheet.getName()}", row ${i+1} is not a number. It will be appended as is.`);
            }
          } else { // If not "Investment Refund", it must be "LR-FD"
            // For "LR-FD", take value from 1 column to the right
            extractedCol3 = sourceData[i][checkColIndex + 1];
          }

          const rowData = [
            sourceData[i][checkColIndex - 2], // 2 columns to the left of the keyword
            sourceData[i][checkColIndex - 1], // 1 column to the left of the keyword
            extractedCol3                     // Determined based on the keyword (1 or 2 columns right, potentially negative)
          ];

          let exists = false;
          if (existingData.length > 0) {
            exists = existingData.some(row => row.join() === rowData.join());
          }

          if (!exists) {
            // Append the row to columns A, B, C, starting from appendRow.
            targetSheet.getRange(appendRow, 1, 1, 3).setValues([rowData]);
            appendRow++; // Increment appendRow for the next row.
          }
        }
      }
    }
  });
}

function NSEPrice(symbol) {
  var url = "https://www.nseindia.com/api/quote-equity?symbol=" + symbol;

  // Step 1: Get cookies from NSE homepage
  var headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
    "Accept": "application/json",
    "Accept-Language": "en-US,en;q=0.9",
    "Referer": "https://www.nseindia.com/"
  };

  var initResp = UrlFetchApp.fetch("https://www.nseindia.com/", { "headers": headers });
  var cookies = initResp.getAllHeaders()["Set-Cookie"];
  if (Array.isArray(cookies)) {
    cookies = cookies.map(function(c){ return c.split(";")[0]; }).join("; ");
  } else {
    cookies = cookies.split(";")[0];
  }

  // Step 2: Call API with cookies
  headers["Cookie"] = cookies;
  var response = UrlFetchApp.fetch(url, { "headers": headers });
  var data = JSON.parse(response.getContentText());

  return data["priceInfo"]["lastPrice"];
}


/**
 * Fetches the current price for Nexus Select Trust (NXST) from Yahoo Finance.
 * Usage: =GET_NXST()
 * @customfunction
 */
function GET_NXST() {
  try {
    // Fetches data for the NSE listing of Nexus Select Trust
    const url = "https://query1.finance.yahoo.com/v8/finance/chart/NXST.NS?interval=1d&range=1d";
    const response = UrlFetchApp.fetch(url);
    const data = JSON.parse(response.getContentText());
    
    // Extract the regular market price
    const price = data.chart.result[0].meta.regularMarketPrice;
    return price;
  } catch (e) {
    return "Error fetching data";
  }
}